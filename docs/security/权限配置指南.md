# 权限配置和管理指南

## 🔐 权限架构总览

这个系统有**两个关键角色**，分工明确：

```
┌─────────────────────────────────────────────────────┐
│              LicodeToken 合约                        │
├─────────────────────────────────────────────────────┤
│                                                      │
│  1️⃣ OWNER（所有者）                                  │
│     - 可以更换 distributor                           │
│     - 可以提取代币到其他地址（ownerWithdraw）          │
│     - 拥有最高管理权限                                │
│                                                      │
│  2️⃣ DISTRIBUTOR（分发者）                            │
│     - 只能调用 distribute() 分发代币                  │
│     - 必须遵守上限规则                                │
│     - 不能提取或转移代币到任意地址                      │
│                                                      │
│  📦 代币持有：合约本身                                 │
│     - 全部供应量铸造到合约地址                          │
│     - balanceOf(contractAddress) = 全部代币           │
└─────────────────────────────────────────────────────┘
```

---

## 📋 详细权限列表

### 1️⃣ OWNER（所有者）权限

```solidity
// 合约代码
contract LicodeToken is ERC20, Ownable {

    // ✅ Owner 可以做的事：

    // 1. 更换 distributor
    function setDistributor(address _d) external onlyOwner {
        distributor = _d;
    }

    // 2. 提取代币（用于LP、财库等）
    function ownerWithdraw(address to, uint256 amount) external onlyOwner {
        _transfer(address(this), to, amount);
    }
}
```

**Owner 的职责：**
- 🔧 管理员角色
- 🔄 轮换 distributor（如私钥泄露）
- 💰 提取代币建立 LP 池
- 🏦 转移代币到财库

**Owner 不能做：**
- ❌ 不能直接分发代币给用户（只能通过 distributor）
- ❌ 不能修改上限（上限是 immutable）
- ❌ 不能增发代币（总量固定）

---

### 2️⃣ DISTRIBUTOR（分发者）权限

```solidity
// 合约代码
modifier onlyDistributor() {
    require(msg.sender == distributor, "not distributor");
    _;
}

// ✅ Distributor 唯一能做的事：
function distribute(address to, uint256 usdcAmount6) external onlyDistributor {
    // 检查上限
    require(usdcCounted + usdcAmount6 <= totalUsdcCap, "total cap reached");
    require(usdcByWallet[to] + usdcAmount6 <= perWalletUsdcCap, "wallet cap reached");

    // 计算代币数量
    uint256 tokenAmount = (usdcAmount6 * tokensPerUsdc) / 1e6;

    // 转账
    _transfer(address(this), to, tokenAmount);
}
```

**Distributor 的职责：**
- 🤖 自动化分发代币
- ✅ 后端服务器调用
- 🎯 验证支付后分发

**Distributor 不能做：**
- ❌ 不能提取代币到任意地址（只能按规则分发）
- ❌ 不能超过上限分发
- ❌ 不能修改合约参数
- ❌ 不能更换 owner 或 distributor

---

## 🚀 完整配置流程

### 步骤1: 准备钱包地址

你需要准备**3个地址**：

```bash
# 1. DEPLOYER（部署者）- 可以与OWNER相同
DEPLOYER_ADDRESS=0x1111...1111  # 部署合约的地址
DEPLOYER_PRIVATE_KEY=0xaaa...   # 需要私钥

# 2. OWNER（所有者）- 管理员
OWNER_ADDRESS=0x2222...2222     # 管理合约的地址
# 可以是多签钱包（推荐）或冷钱包

# 3. DISTRIBUTOR（分发者）- 后端服务器
DISTRIBUTOR_ADDRESS=0x3333...3333  # 后端使用的地址
DISTRIBUTOR_PRIVATE_KEY=0xbbb...   # 后端需要这个私钥

# 4. TREASURY（财库）- 接收USDC
TREASURY_ADDRESS=0x4444...4444  # 收款地址
```

**安全建议：**
- ✅ **OWNER**: 使用多签钱包（如 Gnosis Safe）或硬件钱包
- ✅ **DISTRIBUTOR**: 专用热钱包，只放少量ETH做gas
- ✅ **TREASURY**: 冷钱包或多签钱包
- ✅ **DEPLOYER**: 可以和OWNER相同

---

### 步骤2: 配置环境变量

#### **根目录 .env（部署合约用）**
```bash
# 部署者私钥
DEPLOYER_PRIVATE_KEY="0xaaa..."

# 管理员地址（Owner）
OWNER_ADDRESS="0x2222...2222"

# 分发者地址（Distributor）
DISTRIBUTOR_ADDRESS="0x3333...3333"

# 代币参数
TOKEN_NAME="LICODE"
TOKEN_SYMBOL="LICODE"
TOTAL_SUPPLY_18="1000000000"     # 10亿代币
TOKENS_PER_USDC_18="5000"        # 1 USDC = 5000 LICODE
TOTAL_USDC_CAP_6="100000000000"  # 总上限 100,000 USDC
PER_WALLET_USDC_CAP_6="10000000" # 单钱包 10 USDC

# RPC
RPC_URL_BASE="https://mainnet.base.org"
```

#### **backend/.env（后端服务用）**
```bash
# 分发者私钥（重要！后端需要用它签名交易）
DISTRIBUTOR_PRIVATE_KEY="0xbbb..."

# 合约地址（部署后填写）
TOKEN_ADDRESS="0x5555...5555"

# USDC地址（Base主网）
USDC_ADDRESS="0x833589fcd6edb6e08f4c7c32d4f71b54bda02913"

# 财库地址（收USDC的地址）
TREASURY_ADDRESS="0x4444...4444"

# 铸造价格（6位小数）
MINT_USDC_6="1000000"  # 1 USDC

# 链ID
CHAIN_ID="8453"  # Base主网
```

---

### 步骤3: 部署合约

```bash
# 编译
pnpm build

# 部署（先测试网）
pnpm run deploySepolia

# 输出示例：
# Deployer: 0x1111...1111
# LicodeToken deployed: 0x5555...5555

# 记录合约地址
TOKEN_ADDRESS="0x5555...5555"
```

**部署后合约状态：**
```
合约地址: 0x5555...5555
  ├─ owner: 0x2222...2222 (OWNER_ADDRESS)
  ├─ distributor: 0x3333...3333 (DISTRIBUTOR_ADDRESS)
  └─ balanceOf(0x5555...5555): 1,000,000,000 LICODE（全部代币）
```

---

### 步骤4: 验证权限配置

创建一个检查脚本：

```javascript
// scripts/checkPermissions.ts
import { ethers } from "hardhat";

async function main() {
  const tokenAddress = process.env.TOKEN_ADDRESS!;
  const token = await ethers.getContractAt("LicodeToken", tokenAddress);

  console.log("=== 权限检查 ===");
  console.log("合约地址:", tokenAddress);
  console.log("Owner:", await token.owner());
  console.log("Distributor:", await token.distributor());
  console.log("代币余额:", ethers.formatUnits(await token.balanceOf(tokenAddress), 18));
  console.log("总供应量:", ethers.formatUnits(await token.totalSupply(), 18));
}

main();
```

```bash
# 运行检查
TOKEN_ADDRESS=0x5555...5555 npx hardhat run scripts/checkPermissions.ts --network baseSepolia
```

---

### 步骤5: 配置后端服务器

```bash
# 1. 配置 backend/.env
# 确保 DISTRIBUTOR_PRIVATE_KEY 对应 DISTRIBUTOR_ADDRESS

# 2. 给 DISTRIBUTOR_ADDRESS 充值 ETH（用于gas）
# 建议：0.05 - 0.1 ETH（取决于预期铸造次数）

# 3. 启动后端
cd backend
pnpm run dev

# 检查输出：
# Distributor signer: 0x3333...3333  ← 应该匹配DISTRIBUTOR_ADDRESS
# Backend on :3001
```

---

## 🔄 如何更换 Distributor

如果需要更换 distributor（如私钥泄露或升级服务器）：

### 方法1: 使用 Hardhat 脚本

```javascript
// scripts/changeDistributor.ts
import { ethers } from "hardhat";

async function main() {
  const tokenAddress = process.env.TOKEN_ADDRESS!;
  const newDistributor = process.env.NEW_DISTRIBUTOR_ADDRESS!;

  const [owner] = await ethers.getSigners();  // 必须是owner账户
  const token = await ethers.getContractAt("LicodeToken", tokenAddress, owner);

  console.log("当前 distributor:", await token.distributor());
  console.log("新 distributor:", newDistributor);

  const tx = await token.setDistributor(newDistributor);
  await tx.wait();

  console.log("✅ Distributor 已更换！");
  console.log("交易哈希:", tx.hash);
}

main();
```

```bash
# 运行（需要OWNER私钥）
NEW_DISTRIBUTOR_ADDRESS=0x6666...6666 \
DEPLOYER_PRIVATE_KEY=<OWNER私钥> \
npx hardhat run scripts/changeDistributor.ts --network base
```

### 方法2: 使用 Etherscan（推荐生产环境）

```bash
1. 访问 Basescan
2. 找到合约地址
3. 连接钱包（Owner钱包）
4. Write Contract → setDistributor
5. 输入新地址 → 提交交易
```

**⚠️ 更换后必须同步更新：**
```bash
# backend/.env
DISTRIBUTOR_PRIVATE_KEY="<新的私钥>"

# 重启后端服务
```

---

## 💰 如何提取代币到LP池

```bash
# 1. 配置 .env
WITHDRAW_TO_ADDRESS="0x7777...7777"  # LP钱包或财库
WITHDRAW_AMOUNT_18="500000000"       # 提取5亿代币
TOKEN_ADDRESS="0x5555...5555"

# 2. 运行提取脚本（需要OWNER私钥）
DEPLOYER_PRIVATE_KEY=<OWNER私钥> \
npx hardhat run scripts/withdraw.ts --network base

# 输出：
# Sending 500000000 LICODE to 0x7777...7777 ...
# Withdraw complete.
```

**提取后状态：**
```
合约余额: 500,000,000 LICODE（剩余）
LP钱包余额: 500,000,000 LICODE（提取的）
```

---

## 🔒 安全最佳实践

### 1. 密钥管理
```bash
# ✅ 推荐配置
OWNER          → 多签钱包（Gnosis Safe 3/5）
DISTRIBUTOR    → 专用热钱包（服务器）+ 监控
TREASURY       → 冷钱包或多签
DEPLOYER       → 临时密钥（部署后可丢弃）

# ❌ 避免
同一个私钥用于多个角色
私钥直接写在代码里
使用个人主钱包作为 distributor
```

### 2. 后端安全
```bash
# backend/.env（生产环境）
DISTRIBUTOR_PRIVATE_KEY=<加密存储>  # 使用 AWS KMS 或 HashiCorp Vault

# 监控 distributor 余额
if (balance < 0.01 ETH) {
  alert("Distributor 余额不足！");
}

# 记录所有分发交易
logger.info({ user, amount, txHash, timestamp });
```

### 3. 权限最小化
```javascript
// Distributor 只能：
✅ 调用 distribute(user, amount)  // 有上限保护
❌ 不能调用 ownerWithdraw()
❌ 不能调用 setDistributor()
❌ 不能转移超过上限的代币
```

### 4. 应急预案
```bash
# 如果 distributor 私钥泄露：
1. 立即使用 owner 账户调用 setDistributor(新地址)
2. 停止后端服务
3. 更换密钥
4. 重新部署后端

# 如果 owner 私钥泄露：
1. 合约无法转移 ownership（OpenZeppelin Ownable 默认不支持）
2. 建议使用多签钱包作为 owner 避免此问题
```

---

## 📊 权限配置检查清单

部署前检查：

```bash
☐ 准备了4个地址（deployer, owner, distributor, treasury）
☐ OWNER 使用多签或硬件钱包
☐ DISTRIBUTOR 是专用地址（不用于其他用途）
☐ 配置了根目录 .env（部署参数）
☐ 配置了 backend/.env（后端参数）
☐ DISTRIBUTOR_ADDRESS 有足够ETH支付gas（≥0.05 ETH）
☐ USDC_ADDRESS 是正确的 Base 主网地址
☐ 在测试网验证了完整流程

部署后检查：

☐ 合约 owner() 返回正确的 OWNER_ADDRESS
☐ 合约 distributor() 返回正确的 DISTRIBUTOR_ADDRESS
☐ 合约余额 = 总供应量
☐ 后端启动成功，显示正确的 distributor 地址
☐ 后端可以成功调用 distribute()（测试网验证）
☐ 在 Basescan 上验证合约
☐ 配置监控和告警
☐ 备份所有私钥（加密保存）
```

---

## 🎯 总结

**权限设计核心：**

1. **OWNER**（管理员）= 控制权，可以换distributor、提取代币
2. **DISTRIBUTOR**（机器人）= 执行权，只能按规则分发代币
3. **合约本身** = 代币保管箱，所有代币存放在这里

**发放代币的流程：**
```
后端验证支付 → 调用 token.distribute(user, amount) → 代币从合约转给用户
                ↑
          需要 DISTRIBUTOR_PRIVATE_KEY 签名
```

**安全保障：**
- Distributor 权限受限（只能分发，有上限保护）
- Owner 可以随时更换 distributor
- 代币在合约中安全存放
- 所有操作链上可验证

准备好了就可以部署！建议先在测试网完整跑一遍流程。
