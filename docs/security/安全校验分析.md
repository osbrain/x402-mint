# 前端后端安全校验分析

## 🔍 当前安全机制分析

### 现有的安全验证

后端 `/verify` 接口的验证流程：

```javascript
app.post("/verify", async (req, res) => {
  const { txHash, user } = req.body;

  // ✅ 验证1: 交易是否确认
  const rcpt = await provider.getTransactionReceipt(txHash);
  if (!rcpt || rcpt.status !== 1) {
    return res.status(400).json({ error: "tx not confirmed" });
  }

  // ✅ 验证2: 解析 USDC Transfer 事件
  for (const log of rcpt.logs) {
    const parsed = USDC.interface.parseLog({ data: log.data, topics: log.topics });
    if (parsed?.name === "Transfer") {
      const from = parsed.args[0].toLowerCase();
      const to = parsed.args[1].toLowerCase();
      const value = parsed.args[2];

      // ✅ 验证3: 检查支付方和收款方
      if (from === user.toLowerCase() && to === TREASURY) {
        paid6 += value;
      }
    }
  }

  // ✅ 验证4: 检查支付金额
  if (paid6 < required6) {
    return res.status(400).json({ error: "insufficient payment" });
  }

  // ✅ 验证5: 检查钱包上限
  const soFar = await token.usdcByWallet(user);
  if (soFar + required6 > perWallet) {
    return res.status(400).json({ error: "wallet cap reached" });
  }

  // ✅ 验证6: 调用合约分发
  await token.distribute(user, required6);
});
```

---

## ✅ 当前安全保障

### 1. **链上验证（核心安全）**

这是最重要的安全机制！

```javascript
// 后端不信任前端，直接从区块链读取真实数据
const rcpt = await provider.getTransactionReceipt(txHash);
//              ↑
//      直接从 Base 链上查询，无法伪造
```

**为什么安全：**
- ✅ 交易数据来自区块链，不可篡改
- ✅ Transfer 事件由 USDC 合约发出，无法伪造
- ✅ 验证了 `from === user` 和 `to === TREASURY`
- ✅ 金额直接从事件读取，前端无法修改

**攻击失败案例：**
```javascript
// ❌ 攻击者尝试：
POST /verify {
  txHash: "0xaaa...",  // 真实的交易哈希
  user: "0x攻击者地址"  // 伪造的地址
}

// 后端验证：
const from = parsed.args[0];  // 从链上读取 = "0x真实用户"
if (from === user) {  // "0x真实用户" !== "0x攻击者地址"
  // ❌ 验证失败，攻击者无法获得代币
}
```

### 2. **金额验证**

```javascript
// 后端从链上事件读取实际支付金额
const value = parsed.args[2];  // 链上真实金额
paid6 += value;

// 检查是否足够
if (paid6 < required6) {
  return res.status(400).json({ error: "insufficient payment" });
}
```

**为什么安全：**
- ✅ 金额直接从链上读取，前端无法修改
- ✅ 即使前端说"我支付了100 USDC"，后端只信任链上数据

### 3. **上限检查**

```javascript
// 检查链上记录的用户已铸造量
const soFar = await token.usdcByWallet(user);  // 从合约读取
const perWallet = await token.perWalletUsdcCap();

if (soFar + required6 > perWallet) {
  return res.status(400).json({ error: "wallet cap reached" });
}
```

**为什么安全：**
- ✅ 数据来自合约状态，无法篡改
- ✅ 即使前端多次请求，合约会拒绝超限

---

## ⚠️ 当前安全漏洞

### 🚨 漏洞1: 重放攻击（高危）

**问题：**
同一个 `txHash` 可以多次提交！

```javascript
// 用户A支付1 USDC，获得txHash
const txHash = "0xabc123...";

// 第一次验证 ✅
POST /verify { txHash, user: "0xUserA" }
// → 成功获得 5000 LICODE

// 第二次验证 ✅ （问题！）
POST /verify { txHash, user: "0xUserA" }
// → 又获得 5000 LICODE！

// 可以无限重复...
```

**影响：**
- 用户支付1次USDC，可以获得无限代币
- 合约代币会被耗尽

**攻击场景：**
```bash
# 恶意脚本
for i in {1..1000}; do
  curl -X POST http://api/verify \
    -d '{"txHash":"0xabc123...","user":"0xUserA"}'
done

# 结果：5,000,000 LICODE（应该只有 5,000）
```

---

### 🚨 漏洞2: 监听他人交易（中危）

**问题：**
攻击者可以监听链上交易，抢先提交验证。

```javascript
// 1. 用户A支付 USDC
// 链上交易: 0xdef456...
// Transfer(from: 0xUserA, to: TREASURY, value: 1000000)

// 2. 攻击者Bot监听到这笔交易
const txHash = "0xdef456...";
const from = "0xUserA";

// 3. 攻击者抢先提交（虽然支付的是UserA）
POST /verify {
  txHash: "0xdef456...",
  user: "0xUserA"  // ← 这是UserA的地址，验证会通过
}

// 4. 代币发给了UserA（不是攻击者）
// ❌ 攻击者无法盗取代币
```

**当前状态：**
✅ **此攻击无效** - 因为后端验证 `from === user`，代币会发给真实支付者

**但如果没有验证 `from === user`：**
```javascript
// 危险代码（当前代码没有这个问题）
if (to === TREASURY) {  // 只检查收款方
  await token.distribute(req.body.user, amount);  // 发给请求中的user
  //                      ↑ 如果不验证from，这里就有问题
}
```

---

### 🚨 漏洞3: 缺少速率限制（中危）

**问题：**
没有API速率限制，可被DOS攻击。

```javascript
// 攻击脚本
while (true) {
  POST /verify { txHash: "随机字符串", user: "随机地址" }
  // 虽然会验证失败，但消耗后端资源（RPC查询）
}
```

**影响：**
- 消耗RPC配额
- 服务器CPU/内存占用
- 可能导致服务不可用

---

### 🚨 漏洞4: 缺少CORS和CSRF保护（低危）

**问题：**
没有配置CORS，可能被恶意网站调用。

```html
<!-- 恶意网站 evil.com -->
<script>
fetch('https://your-api.com/verify', {
  method: 'POST',
  body: JSON.stringify({ txHash: '...', user: '...' })
});
</script>
```

**当前影响：**
✅ 由于需要真实的链上交易，攻击者无法凭空伪造
⚠️ 但可以发起大量无效请求

---

## 🛡️ 安全加固方案

### 方案1: 防重放攻击（必须实现）

#### 选项A: Redis缓存已处理的交易

```javascript
import Redis from 'ioredis';
const redis = new Redis(process.env.REDIS_URL);

app.post("/verify", async (req, res) => {
  const { txHash, user } = req.body;

  // 1️⃣ 检查是否已处理
  const processed = await redis.get(`tx:${txHash}`);
  if (processed) {
    return res.status(400).json({ error: "Transaction already processed" });
  }

  // 2️⃣ 验证链上交易...
  const rcpt = await provider.getTransactionReceipt(txHash);
  // ... 现有验证逻辑 ...

  // 3️⃣ 分发代币
  await token.distribute(user, required6);

  // 4️⃣ 标记为已处理（永久存储）
  await redis.set(`tx:${txHash}`, JSON.stringify({
    user,
    amount: required6.toString(),
    timestamp: Date.now()
  }));

  res.json({ ok: true });
});
```

**优点：**
- ✅ 彻底防止重放攻击
- ✅ 可持久化存储
- ✅ 可查询历史记录

**配置：**
```bash
# backend/.env
REDIS_URL="redis://localhost:6379"

# 或使用云服务
REDIS_URL="redis://username:password@redis-cloud.com:12345"
```

#### 选项B: 数据库记录

```javascript
// 使用 SQLite/PostgreSQL
import Database from 'better-sqlite3';
const db = new Database('mint.db');

db.exec(`
  CREATE TABLE IF NOT EXISTS processed_txs (
    tx_hash TEXT PRIMARY KEY,
    user_address TEXT NOT NULL,
    amount TEXT NOT NULL,
    timestamp INTEGER NOT NULL
  )
`);

app.post("/verify", async (req, res) => {
  const { txHash, user } = req.body;

  // 检查是否已处理
  const exists = db.prepare('SELECT 1 FROM processed_txs WHERE tx_hash = ?').get(txHash);
  if (exists) {
    return res.status(400).json({ error: "Transaction already processed" });
  }

  // ... 验证和分发 ...

  // 记录到数据库
  db.prepare(`
    INSERT INTO processed_txs (tx_hash, user_address, amount, timestamp)
    VALUES (?, ?, ?, ?)
  `).run(txHash, user, required6.toString(), Date.now());

  res.json({ ok: true });
});
```

#### 选项C: 合约状态验证（最安全，但gas较高）

```solidity
// 修改合约，记录已使用的txHash
contract LicodeToken is ERC20, Ownable {
    mapping(bytes32 => bool) public usedTxHashes;

    function distribute(address to, uint256 usdcAmount6, bytes32 txHash)
        external onlyDistributor {
        require(!usedTxHashes[txHash], "tx already used");

        usedTxHashes[txHash] = true;

        // ... 现有分发逻辑 ...
    }
}
```

**缺点：**
- ❌ 需要重新部署合约
- ❌ 每次分发需要额外gas存储txHash

---

### 方案2: 速率限制（推荐）

```bash
npm install express-rate-limit
```

```javascript
import rateLimit from 'express-rate-limit';

// 全局限制
const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100, // 最多100个请求
  message: 'Too many requests, please try again later'
});

// verify接口专用限制（更严格）
const verifyLimiter = rateLimit({
  windowMs: 60 * 1000, // 1分钟
  max: 5, // 最多5个请求
  keyGenerator: (req) => {
    // 按IP + 用户地址限制
    return `${req.ip}:${req.body.user}`;
  },
  message: 'Too many verification attempts, please wait'
});

app.use(globalLimiter);
app.post("/verify", verifyLimiter, async (req, res) => {
  // ... 验证逻辑 ...
});
```

---

### 方案3: CORS配置

```javascript
import cors from 'cors';

const corsOptions = {
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  methods: ['GET', 'POST'],
  credentials: true
};

app.use(cors(corsOptions));
```

```bash
# backend/.env
FRONTEND_URL="https://your-frontend.com"
```

---

### 方案4: 签名验证（可选，增强安全）

**思路：**
前端用用户钱包签名请求，后端验证签名。

```javascript
// 前端（使用 ethers.js）
import { ethers } from 'ethers';

async function verifyPayment(txHash, userAddress, signer) {
  // 1. 构造消息
  const message = `Verify payment: ${txHash} for ${userAddress}`;

  // 2. 用户签名
  const signature = await signer.signMessage(message);

  // 3. 发送到后端
  await axios.post('/api/verify', {
    txHash,
    user: userAddress,
    signature,
    message
  });
}
```

```javascript
// 后端验证
app.post("/verify", async (req, res) => {
  const { txHash, user, signature, message } = req.body;

  // 1️⃣ 验证签名
  const recoveredAddress = ethers.verifyMessage(message, signature);
  if (recoveredAddress.toLowerCase() !== user.toLowerCase()) {
    return res.status(400).json({ error: "Invalid signature" });
  }

  // 2️⃣ 验证消息格式
  const expectedMessage = `Verify payment: ${txHash} for ${user}`;
  if (message !== expectedMessage) {
    return res.status(400).json({ error: "Invalid message" });
  }

  // 3️⃣ 防止签名重放（添加时间戳）
  const timestamp = Date.now();
  const messageWithTimestamp = `${message}:${timestamp}`;
  // ... 检查时间戳是否在5分钟内 ...

  // 4️⃣ 继续现有验证逻辑...
});
```

**优点：**
- ✅ 证明请求确实来自代币接收者
- ✅ 防止第三方抢跑

**缺点：**
- ❌ 增加前端复杂度
- ❌ 用户需要额外签名操作

---

## 🎯 推荐的最小安全配置

### 立即实现（必须）：

```javascript
// backend/src/server.ts

import express from 'express';
import rateLimit from 'express-rate-limit';
import cors from 'cors';
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

// 1️⃣ CORS保护
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000'
}));

// 2️⃣ 速率限制
const verifyLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: 5,
  keyGenerator: (req) => `${req.ip}:${req.body.user || 'unknown'}`
});

// 3️⃣ 防重放攻击
app.post("/verify", verifyLimiter, async (req, res) => {
  const { txHash, user } = req.body;

  // 检查是否已处理
  const processed = await redis.get(`tx:${txHash}`);
  if (processed) {
    console.warn("Replay attack detected", { txHash, user });
    return res.status(400).json({ error: "Transaction already processed" });
  }

  // ... 现有验证逻辑 ...

  // 分发代币
  const tx = await token.distribute(user, required6);
  await tx.wait();

  // 标记为已处理
  await redis.set(`tx:${txHash}`, JSON.stringify({
    user,
    amount: required6.toString(),
    distributorTx: tx.hash,
    timestamp: Date.now()
  }));

  res.json({ ok: true, tx: tx.hash });
});
```

### 配置文件：

```bash
# backend/.env
REDIS_URL="redis://localhost:6379"
FRONTEND_URL="http://localhost:3000"  # 生产环境改为实际域名
```

### 安装依赖：

```bash
cd backend
npm install express-rate-limit cors ioredis
npm install --save-dev @types/cors
```

---

## 📊 安全评分

| 安全机制 | 当前状态 | 加固后 |
|---------|---------|--------|
| **链上验证** | ✅ 100% | ✅ 100% |
| **防重放攻击** | ❌ 0% | ✅ 100% |
| **速率限制** | ❌ 0% | ✅ 100% |
| **CORS保护** | ❌ 0% | ✅ 100% |
| **签名验证** | ❌ 0% | ⚠️ 可选 |

**总体评分：**
- 当前：60/100（核心验证强，但缺乏应用层防护）
- 加固后：95/100（生产环境可用）

---

## ✅ 总结

### 当前安全机制（已有）：

1. ✅ **链上验证是核心** - 这是最重要的安全保障
   - 数据来自区块链，不可篡改
   - 验证 from/to/amount，前端无法伪造

2. ✅ **金额和地址验证** - 从链上事件读取
3. ✅ **上限检查** - 合约强制执行

### 需要立即补充：

1. 🚨 **防重放攻击** - Redis/数据库记录已处理的txHash
2. ⚠️ **速率限制** - 防止DOS攻击
3. ⚠️ **CORS配置** - 限制来源

### 核心安全原则：

> **"不信任前端，只信任区块链"**

前端可以发送任何数据，但后端：
- ✅ 直接从链上读取真实交易
- ✅ 验证交易的from/to/amount
- ✅ 不依赖前端提供的金额数据
- ✅ 通过合约强制执行上限

**只要加上防重放攻击，这个系统就是安全的！**
